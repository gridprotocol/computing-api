# 合约开发

列举了每个合约的数据结构具体定义和需求描述。合约的开发需要安全可审计。

理论上使用的流程是：

1. 计算节点在注册合约中登记自己的资源信息与ip或域名。
1. 用户与计算节点协商好后可在市场合约中创建订单，订单内容包括资源量、定价以及用户质押的代币量。其中代币量和定价可以用于计算出服务时长。`msg.sender`表明是哪个用户创建的订单，并通过参数指明计算节点的地址。
1. 计算节点调用合约方法激活订单，此时`msg.sender`表明计算节点接受该订单。激活后会将用户`approve`的代币根据订单定义的质押量划转到市场合约并记录。
1. 后续订单持续过程中有试用期与释放期。在试用期内的服务结算不会扣除代币，在释放期内代币报酬随时间释放给提供服务的计算节点。
1. 用户和计算节点随时可以取消订单或服务结算，且取消订单时会对服务进行结算。
1. 用户和计算节点提取代币时也会进行的未完成的服务结算。

资源的衡量主要包括：

1. CPU
2. GPU
3. Memory
4. Disk
5. Traffic

## 注册合约

功能描述：

用于登记计算节点的必要信息。用户或平台可以通过计算节点的地址和该合约获取提供服务的计算节点的详细信息。

数据结构：

1. `struct resources`，用于记录计算节点的资源情况。包括cpu、内存、存储、gpu。需要有两个变量记录，一个用于记录所有资源量，一个用于记录目前可用的资源量，每次订单都会减少对应的可用资源量。
1. `struct info`，用于记录计算节点的详细信息。内含两个`resources`变量，以及节点的IP地址或域名。
1. `mapping(address => info) registry`。其中`key`为计算节点的账户地址，`value`为计算节点的详细信息。

函数逻辑：

1. `Get`，用于获取计算节点当前的详细信息。传入计算节点的地址。
1. `Set`，用于设置计算节点的详细信息。计算节点作为调用者，传入详细信息。
1. `Update`，用于更新可用资源量的信息。调用者为市场合约，每次订单激活后就会减去相应的可用资源量，订单取消或完成后就会释放占用的资源量。

开发需求：

实现数据结构和函数逻辑，保证流程中与注册合约相关的[步骤](#合约开发)能够正确执行。

## 市场合约

功能描述：

记录用户与计算节点之间的订单关系。通过合约逻辑执行的方式完成服务的签订与报酬的分配。

数据结构：

1. `struct order`，记录订单信息。内含`pricePerHour`以及`resources`结构记录订单的价格以及租用的资源量。此外还有`deposit`记录用户质押代币量，`remuneration`记录计算节点获取的报酬量，`userCheck`和`providerCheck`记录双方是否确认，`activateHeight`记录订单激活时的高度，`settleHeight`记录结算高度，`probation`记录试用期长度，`duration`记录服务时长，以及`isRunning`记录订单是否执行中或已经停止等（可以有多个值表示不同的状态，如未激活、运行、终止、完成）。
1. `mapping(address => mapping(address => order)) orders`，记录用户与计算节点之间的订单。`key1`为用户地址，`key2`为计算节点的地址。

单位资源的价格不再在合约中展现，而是通过其他方式如链下表格建议等，让用户或计算节点计算出参考价格，最终在订单中体现的价格应为总和资源的使用价格（token/time），其中时间单位可用时间戳的秒或者转换成区块高度来换算。

函数逻辑：

1. `createOrder`，用户生成订单。在生成订单前需要在代币合约中`approve`该合约足够的代币，满足订单内记录的质押量。且在创建订单时，如果之前双方之间有未完成的订单，会触发失败，必须取消或者完成上笔订单后才能创建新的订单覆盖，如果原订单内还有未转出的token，也会先转出清零后再创建新订单。传入`order`相关参数以及计算节点的地址。
1. `cancelOrder`，用户或计算节点取消订单。取消订单时会调用`settle`完成服务的结算，并将订单的状态置为停止状态，表明后续不再结算，最后通过`withdraw`将双方的余额从合约中转出。传入用户地址或计算节点地址，配合`msg.sender`，确定要取消的订单。
1. `settle`，用于进行服务代币结算。即结算已经随时间释放的那部分代币，需要根据订单参数中的试用期长度、当前区块高度与结算高度实现释放逻辑。如果调用`settle`时已经超过了订单的服务时长，即可认为服务已经完成，将订单状态变更为完成。传入用户地址与计算节点地址，确定要进行结算的订单。
1. `activateOrder`，计算节点调用，用于激活用户创建的合约，开始服务。传入用户地址以确认订单。
1. `withdraw`，用户或者计算节点调用可以取出在订单内的余额。需要订单处于完成或停止状态，会调用`settle`进行未完成的结算，再调用相关的代币合约完成转账。传入要取出的代币量，用户地址或计算节点地址，配合`msg.sender`确定订单。
1. `checkPermission`，用于验证用户是否有权限创建订单，避免女巫攻击。但目前还没完全确定这块逻辑怎么做，后续可能也会通过试用期长度来做，可以先留空在这。

开发需求：

实现数据结构和函数逻辑，保证流程中与注册合约相关的[步骤](#合约开发)能够正确执行。

## 代币合约

这块可以直接沿用Memo的Token合约逻辑。**测试时可以随便使用一个ERC20代币合约完成与转账相关的操作。**

代币合约与交易以及质押激励相关。

功能描述：

针对市场合约中的订单交易，与代币相关的操作。用户与计算节点质押、提取时都会与该合约交互。

数据结构：

ERC20相关，可以再加上发行以及mint相关的结构。

函数逻辑：

ERC20合约的基本逻辑。

开发需求：

无。

### 质押合约

属于代币合约的扩展合约。

有个pool合约用于将代币质押到池中。通过统计账户质押的代币量与池内的质押代币总量计算分润比，在ERC20代币合约增发代币时，会将增发的代币转入池中，从池中提取代币时除了本金外就是额外的收益了。

（注意，质押到池中只是易懂的说法，实际上是将代币转移到池合约的ERC20地址中）

代币增发逻辑：

- 创建ERC20合约时mint一部分初始代币到pool合约中。前期这部分初始代币每隔一定数量的区块发放固定数量的代币给质押了指定额度的地址，发放完后不再发放。地址在质押后会记录其起始质押时间，地址在调用结算或取出质押代币时会更新其质押收益，取出质押代币后会清除其质押时间记录。
- 后期可做成与订单相关。在代币增发达到上限之前，根据订单完成的代币交易量增发等额或等比例的代币（即以计算节点获得的代币报酬量为基准）。

## 扩展需求

主要有两部分扩展需求，分别对应不同的问题：

1. 用户创建订单时的门槛机制。
2. 信誉分机制（对用户和计算节点都有记录）。

对于1的门槛机制，目的是为了限制DoS攻击的强度。当gasfee很低时，用户可以频繁创建订单来占用计算节点的资源，随后在试用期结束前取消，而仅需付出不高的代价。需要有一个门槛机制，限制女巫攻击生成的地址来创建订单。

对于2的信誉分机制，可以给用户和计算节点一些参考数据来判断是否签订服务订单，提升后续双方的体验。预想信誉分应与订单的完成，或者订单在试用期前后取消，以及在服务期中服务的平均时长相关。可能会有一个合约专门用于记录每个地址对应的数据，辅助市场合约或注册合约的使用。
